---
layout: post
title: "Principal component analysis"
description: "An intuitive derivation of PCA based on graphs"
tags:
giscus_comments: false
date: 2025-05-18
featured: false
categories: math
thumbnail:
related_posts: false
---

### Introduction

It's not a real blog unless I give my take on PCA.

There are several other [blog posts](https://alexhwilliams.info/itsneuronalblog/2016/03/27/pca/) out there that provide intuition for PCA, but most tend to fall back on the idea of "maximizing variance explained".
This intuition never fully clicked for me.
As my [research turned more toward graphs](/blog/category/spatial-omics), I tried to derive PCA from more of a graph perspective, omitting explicit mention of variance altogether.
Here, I'll briefly share the intuition that did end up clicking: it turns out that **variance explained can instead be thought of as the similarity between two graphs**.


### Problem statement

Consider the data matrix

$$
\mathbf{X} \in \mathbb{R}^{n \times g},
$$

where $n$ is the number of observations and $g$ is the number of features.
Given my background in single-cell omics, I tend to think of this as a cell-by-gene matrix -- hence the odd choice of $g$.
In this case, each row corresponds to a measured cell, each column the genes measured across all cells, and each entry the amount that a given gene is expressed in a given cell.
(I'll continue to refer to observations as cells and features as genes just to tie things down to an application.)
Viewed as a dimensionality reduction algorithm, the goal of PCA is to reduce "unnecessary" information, thereby emphasizing more prominent patterns in the data.
But how do we specify that mathematically?

First, we need to explicitly specify **what patterns we're interested in**.
The patterns we will focus on are the relationships between cells (although the relationships between genes would lead to the same result).
More specifically, we will consider the pairwise relationships of all cells in terms of their genes.
To do this for all pairs of cells, we can calculate the matrix product

$$
\mathbf{X} \mathbf{X}^{\top} \in \mathbb{R}^{n \times n},
$$

where each entry describes the similarity between cells $i$ and $j$.
Assuming proper mean centering of $\mathbf{X}$, this is simply a covariance matrix.
However, in keeping with a graph perspective, we can instead think of this as a network connecting similar cells to one another.
It's not sparse like most adjacency matrices -- in fact it's dense with connections from each cell to all others.
But these connections are weighted by similarity, enabling us to intuitively think of $\mathbf{X} \mathbf{X}^{\top}$ as a graph connecting molecularly similar cells.

Next, we need to specify **what "reducing information" means**.
Let's think of it as trying to assign each cell a single value (or "metagene") while trying to maintain the original molecular relationships between cells.
Quantitatively, these new values correspond to a vector $\mathbf{v} \in \mathbb{R}^n$.
Just as the true molecular relationships between cells were given by $\mathbf{X} \mathbf{X}^{\top} \in \mathbb{R}^{n \times n}$, the graph resulting from our new values is given by

$$
\mathbf{v} \mathbf{v}^{\top} \in \mathbb{R}^{n \times n}.
$$

Finally, because we want to maintain the original graph structure as best we can, **we need a way to compare the two graphs**.
We'll do it by summing over the similarities between edge weights in each graph, which are just the individual entries.
(To be clear, this entails summing over "similarities between similarities", which hopefully isn't too confusing.)
This leads us to our final metric for the similarity between our two graphs:

$$
\lambda = \sum_{ij} (\mathbf{X} \mathbf{X}^{\top})_{ij} (\mathbf{v} \mathbf{v}^{\top})_{ij}.
$$


### Solution

Now we can ask: **how do we maximize this similarity?**
It turns out we can solve this just by simplifying the equation.
Let $\mathbf{C} = \mathbf{X} \mathbf{X}^{\top}$ represent our original graph of molecular relationships between cells.
Then we can rearrange our metric into

$$
\lambda = \sum_{ij} \mathbf{C}_{ij} v_i v_j.
$$

This simplifies to the [quadratic form](https://gregorygundersen.com/blog/2022/02/27/positive-definite/)

$$
\lambda = \mathbf{v}^{\top} \mathbf{C} \mathbf{v}.
$$

Now consider that we don't care about the overall magnitude of $\mathbf{v}$.
Rather, we care about its *relative* differences among the cells.
Thus, we should normalize our expression by dividing out the magnitude:

$$
\lambda = \frac{\mathbf{v}^{\top} \mathbf{C} \mathbf{v}}{\mathbf{v}^{\top} \mathbf{v}}.
$$

Finally, we can rearrange this equation into an eigenvalue problem:

$$
\begin{align}
    & \lambda = {\frac{\mathbf{v}^{\top} \mathbf{C} \mathbf{v}}{\mathbf{v}^{\top} \mathbf{v}}} \nonumber \\
    &\rightarrow \lambda \mathbf{v}^{\top} \mathbf{v} = \mathbf{v}^{\top} \mathbf{C} \mathbf{v} \nonumber \\
    &\rightarrow \lambda \mathbf{v} = \mathbf{C} \mathbf{v}. \nonumber
\end{align}
$$

Thus, the maximal $\mathbf{v}$ is just the eigenvector associated with the maximal eigenvalue.
In PCA, this eigenvector is PC1.
The remaining eigenvectors, in order of eigenvalue, are PC2, PC3, etc.
The loadings for each PC (i.e. how much each gene contributes to that pattern over the cell graph) can then be calculated by taking the inner product with each gene, i.e. $\mathbf{X}^{\top} \mathbf{v}$.


### Conclusion

This may seem like quite a bit of leg work, but I think it's worth it for a few reasons.
First, it provides a purely geometric and visual derivation of PCA that may be **more intuitive to those who feel comfortable with graphs**.
Second, it **makes [the connection between PCA and the Fourier transform](https://en.wikipedia.org/wiki/Kosambi%E2%80%93Karhunen%E2%80%93Lo%C3%A8ve_theorem) very clear**, as [eigenvectors of a symmetric matrix are just Fourier modes over the associated graph domain](https://arxiv.org/abs/2303.12211).
Thus, you can think of PCs as the lowest-frequency Fourier modes over the molecular similarity graph.
(This is literally the same math introduced in my [previous post on graph signal processing](/blog/2025/graph-fourier) except that it relies on an adjacency matrix rather than a Laplacian matrix).

Hope you found it insightful.